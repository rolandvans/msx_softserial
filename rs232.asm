;RECEIVING AND SENDING RS232 DATA @57600 BITS/S  ON A STANDARD MSX 3.58MHz 
CPU Z80
FNAME "RS232.BIN"

VOICEAQ:  EQU $F975 ;BUFFER TO OCCUPY IN SYSTEM AREA: DO NOT USE PLAY... 

;MSX .BIN HEADER
DB $FE
DW START, END, START

ORG VOICEAQ
START:
;TRANSFER 'BC' BYTES FROM JOY2, 'UP', PIN1 TO (HL)
;MSX, Z80 3.58MHz 57600bps
;SETS CARRY BIT ON ERROR. A HOLDS ERROR CODE:
;A=1 RS232 LINE NOT HIGH,A=2 STARTBIT TIMEOUT
RECBYTES:	
	DI			;NO INTERRUPTS, TIME CRITICAL ROUTINE
	LD A,$0F	;PSG REGISTER 15, SELECT JOYSTICK PORT 2
	OUT ($A0),A
	IN A,($A2)
	SET 6,A		;SELECT JOY2
	OUT ($A1),A

	LD A,C	; FAST LOOP WITH BC (GRAUW, FAST LOOPS)
	DEC BC	; COMPENSATION FOR THE CASE C=0
	INC B
	LD C,B	; SWAP B AND C FOR LOOP STRUCTURE
	LD B,A

	LD A,$0E	;SET PSG #14
	OUT ($A0),A
	LD E,$01	;FOR FASTER 'AND' OPERATION 'AND r'(5) VS. 'AND n'(8)
	IN A,($A2)
	AND E
	JR NZ,.FIRSTSTARTBIT	;RS232 LINE SHOULD BE HIGH, OTHERWISE STOP
	LD A,$01	;ERROR, RS232 LINE NOT READY
	SCF
	EI
	RET
;THE NEXT PART IS TIME CRITICAL. EVERY CYCLE COUNTS
.FIRSTSTARTBIT:		;WAIT FOR FIRST STARTBIT
	IN A,($A2)
	AND E
	JP NZ,.FIRSTSTARTBIT
	JP .READFIRSTBIT	;START READING BIT0, COMPENSATED FOR 12 CYCLES, 1 JP
.STARTBIT:	
	IN A,($A2)	;WAIT FOR THE HIGH->LOW TRANSITION (STARTBIT)
	AND E
	JP Z,.READBITS
	IN A,($A2)	;WAIT FOR THE HIGH->LOW TRANSITION (STARTBIT)
	AND E
	JP Z,.READBITS
	IN A,($A2)	;WAIT FOR THE HIGH->LOW TRANSITION (STARTBIT)
	AND E
	JP Z,.READBITS
	IN A,($A2)	;WAIT FOR THE HIGH->LOW TRANSITION (STARTBIT)
	AND E
	JP Z,.READBITS
	LD A,$02	;ERROR, STARTBIT TIMEOUT
	SCF
	EI
	RET
.READBITSNEXTBLOCK:
	INC HL
	DEC C	
	JR NZ,.INITBITLOOP	;NEXT BLOCK UNLESS WE ARE DONE (C=0)
	JR .EXIT
.READBITSNEXTBYTE:
	INC HL 
	NOP	;DUMMY
	JR .INITBITLOOP
.READBITS:
	IN A,($A2)	;DUMMY
.READFIRSTBIT:	;ALT TIMING TO COMPENSATE FOR 1 JP
	ADD A,$00	;DUMMY
	NOP	;DUMMY
.INITBITLOOP:
	LD D,B
	LD B,$08
.BITLOOP:	
	INC HL	;DUMMY
	DEC HL	;DUMMY
	IN A,($A2)
	RRCA		;SHIFT DATA BIT (0) -> CARRY
	RR (HL)		;SHIFT CARRY -> [HL]
	DJNZ .BITLOOP
	LD B,D
	DJNZ .STARTBITNEXTBYTE	;NEXT BYTE, SKIP STOPBIT AND WAIT FOR STARTBIT
	NOP	;DUMMY
.STARTBITNEXTBLOCK:
	IN A,($A2)	;WAIT FOR THE HIGH->LOW TRANSITION (STARTBIT)
	AND E
	JP Z,.READBITSNEXTBLOCK
	IN A,($A2)	;WAIT FOR THE HIGH->LOW TRANSITION (STARTBIT)
	AND E
	JP Z,.READBITSNEXTBLOCK
	IN A,($A2)	;WAIT FOR THE HIGH->LOW TRANSITION (STARTBIT)
	AND E
	JP Z,.READBITSNEXTBLOCK
	IN A,($A2)	;WAIT FOR THE HIGH->LOW TRANSITION (STARTBIT)
	AND E
	JP Z,.READBITSNEXTBLOCK
	DEC C	;POSTPONED CHECK
	JR Z,.EXIT	;IF C=0, WE ARE DONE SO EXIT OTHERWISE ERROR
	LD A,$02;	ERROR STARTBIT TIMEOUT
	SCF
	EI
	RET
.STARTBITNEXTBYTE:	
	IN A,($A2)	;WAIT FOR THE HIGH->LOW TRANSITION (STARTBIT)
	AND E
	JP Z,.READBITSNEXTBYTE
	IN A,($A2)	;WAIT FOR THE HIGH->LOW TRANSITION (STARTBIT)
	AND E
	JP Z,.READBITSNEXTBYTE
	IN A,($A2)	;WAIT FOR THE HIGH->LOW TRANSITION (STARTBIT)
	AND E
	JP Z,.READBITSNEXTBYTE
	IN A,($A2)	;WAIT FOR THE HIGH->LOW TRANSITION (STARTBIT)
	AND E
	JP Z,.READBITSNEXTBYTE
	LD A,$02
	SCF
	EI
	RET
.EXIT:
	OR A	;RESET CARRY
	EI
	RET

;SEND 'BC' BYTES FROM [HL] TO PIN6, JOY2
;MSX, Z80 3.58MHz 57600bps
SENDBYTES:	
	DI	;NO INTERRUPTS
	LD A,$0F	;SELECT PSG REG #15
	OUT ($A0),A
	IN A,($A2)	;SAVE VALUE
	PUSH AF
	SET 6,A		;JOY2
	RES 2,A		;TRIG1 LOW
	LD E,A		;0V VALUE (0) IN E
	SET 2,A		;TRIG1 HIGH
	LD D,A		;5V VALUE (1) IN D
.BYTELOOP:	
	PUSH BC
	LD A,E
.STARTBIT:	
	OUT ($A1),A
	LD C,(HL)
	LD B,$08
.BITLOOP:	
	RRC C
;ASSUME BIT=1		
	LD A,D
	JR C,.SETBIT
;NO, BIT=0		
	LD A,E
.SETBIT:	
	ADD A,$00	;DUMMY
	OUT ($A1),A
	DJNZ .BITLOOP
	LD A,E
	POP BC
	DEC BC
	NOP	;DUMMY
	ADD A,$00	;DUMMY
.STOPBIT:	
	LD A,D
	OUT ($A1),A
	INC HL
	LD A,B
	OR C
	NOP	;DUMMY
	JP NZ,.BYTELOOP
.EXIT:
	NOP	;DUMMY
	POP AF
	OUT ($A1),A		
	EI
	RET
END:
